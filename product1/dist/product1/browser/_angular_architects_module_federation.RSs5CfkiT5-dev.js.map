{
  "version": 3,
  "sources": ["../../@angular-architects/module-federation-runtime/fesm2022/angular-architects-module-federation-runtime.mjs", "../../@angular-architects/module-federation/src/index.js"],
  "sourcesContent": ["let config = {};\nconst containerMap = {};\nconst remoteMap = {};\nlet isDefaultScopeInitialized = false;\nasync function lookupExposedModule(key, exposedModule) {\n  const container = containerMap[key];\n  const factory = await container.get(exposedModule);\n  const Module = factory();\n  return Module;\n}\nasync function initRemote(container, key) {\n  // const container = window[key] as Container;\n  // Do we still need to initialize the remote?\n  if (remoteMap[key]) {\n    return container;\n  }\n  // Do we still need to initialize the share scope?\n  if (!isDefaultScopeInitialized) {\n    await __webpack_init_sharing__('default');\n    isDefaultScopeInitialized = true;\n  }\n  await container.init(__webpack_share_scopes__.default);\n  remoteMap[key] = true;\n  return container;\n}\nasync function loadRemoteEntry(remoteEntryOrOptions, remoteName) {\n  if (typeof remoteEntryOrOptions === 'string') {\n    const remoteEntry = remoteEntryOrOptions;\n    return await loadRemoteScriptEntry(remoteEntry, remoteName);\n  } else if (remoteEntryOrOptions.type === 'script') {\n    const options = remoteEntryOrOptions;\n    return await loadRemoteScriptEntry(options.remoteEntry, options.remoteName);\n  } else if (remoteEntryOrOptions.type === 'module') {\n    const options = remoteEntryOrOptions;\n    await loadRemoteModuleEntry(options.remoteEntry);\n  }\n}\nasync function loadRemoteModuleEntry(remoteEntry) {\n  if (containerMap[remoteEntry]) {\n    return Promise.resolve();\n  }\n  return await import(/* webpackIgnore:true */remoteEntry).then(container => {\n    initRemote(container, remoteEntry);\n    containerMap[remoteEntry] = container;\n  });\n}\nasync function loadRemoteScriptEntry(remoteEntry, remoteName) {\n  return new Promise((resolve, reject) => {\n    // Is remoteEntry already loaded?\n    if (containerMap[remoteName]) {\n      resolve();\n      return;\n    }\n    const script = document.createElement('script');\n    script.src = remoteEntry;\n    script.onerror = reject;\n    script.onload = () => {\n      const container = window[remoteName];\n      initRemote(container, remoteName);\n      containerMap[remoteName] = container;\n      resolve();\n    };\n    document.body.appendChild(script);\n  });\n}\nasync function loadRemoteModule(optionsOrRemoteName, exposedModule) {\n  let loadRemoteEntryOptions;\n  let key;\n  let remoteEntry;\n  let options;\n  if (typeof optionsOrRemoteName === 'string') {\n    options = {\n      type: 'manifest',\n      remoteName: optionsOrRemoteName,\n      exposedModule: exposedModule\n    };\n  } else {\n    options = optionsOrRemoteName;\n  }\n  // To support legacy API (< ng 13)\n  if (!options.type) {\n    const hasManifest = Object.keys(config).length > 0;\n    options.type = hasManifest ? 'manifest' : 'script';\n  }\n  if (options.type === 'manifest') {\n    const manifestEntry = config[options.remoteName];\n    if (!manifestEntry) {\n      throw new Error('Manifest does not contain ' + options.remoteName);\n    }\n    options = {\n      type: manifestEntry.type,\n      exposedModule: options.exposedModule,\n      remoteEntry: manifestEntry.remoteEntry,\n      remoteName: manifestEntry.type === 'script' ? options.remoteName : undefined\n    };\n    remoteEntry = manifestEntry.remoteEntry;\n  } else {\n    remoteEntry = options.remoteEntry;\n  }\n  if (options.type === 'script') {\n    loadRemoteEntryOptions = {\n      type: 'script',\n      remoteEntry: options.remoteEntry,\n      remoteName: options.remoteName\n    };\n    key = options.remoteName;\n  } else if (options.type === 'module') {\n    loadRemoteEntryOptions = {\n      type: 'module',\n      remoteEntry: options.remoteEntry\n    };\n    key = options.remoteEntry;\n  }\n  if (remoteEntry) {\n    await loadRemoteEntry(loadRemoteEntryOptions);\n  }\n  return await lookupExposedModule(key, options.exposedModule);\n}\nasync function setManifest(manifest, skipRemoteEntries = false) {\n  config = parseConfig(manifest);\n  if (!skipRemoteEntries) {\n    await loadRemoteEntries();\n  }\n}\nfunction getManifest() {\n  return config;\n}\nasync function initFederation(manifest, skipRemoteEntries = false) {\n  if (typeof manifest === 'string') {\n    return loadManifest(manifest, skipRemoteEntries);\n  } else {\n    return setManifest(manifest, skipRemoteEntries);\n  }\n}\nasync function loadManifest(configFile, skipRemoteEntries = false) {\n  const result = await fetch(configFile);\n  if (!result.ok) {\n    throw Error('could not load configFile: ' + configFile);\n  }\n  config = parseConfig(await result.json());\n  if (!skipRemoteEntries) {\n    await loadRemoteEntries();\n  }\n}\nfunction parseConfig(config) {\n  const result = {};\n  for (const key in config) {\n    const value = config[key];\n    let entry;\n    if (typeof value === 'string') {\n      entry = {\n        remoteEntry: value,\n        type: 'module'\n      };\n    } else {\n      entry = {\n        ...value,\n        type: value.type || 'module'\n      };\n    }\n    result[key] = entry;\n  }\n  return result;\n}\nasync function loadRemoteEntries() {\n  const promises = [];\n  for (const key in config) {\n    const entry = config[key];\n    if (entry.type === 'module') {\n      promises.push(loadRemoteEntry({\n        type: 'module',\n        remoteEntry: entry.remoteEntry\n      }));\n    } else {\n      promises.push(loadRemoteEntry({\n        type: 'script',\n        remoteEntry: entry.remoteEntry,\n        remoteName: key\n      }));\n    }\n  }\n  await Promise.all(promises);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { getManifest, initFederation, loadManifest, loadRemoteEntry, loadRemoteModule, setManifest };\n", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst tslib_1 = require(\"tslib\");\ntslib_1.__exportStar(require(\"@angular-architects/module-federation-runtime\"), exports);\n"],
  "mappings": "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",
  "names": ["config"]
}
